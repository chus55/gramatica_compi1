;	Consideraciones: 
;		1. Todos las producciones "optional" deben tener una produccion "EPSILON"
;		2. __(Done)__ MÃºltiples clases, interfaces, enums fuera de namespace 

code:
	| compilation-unit 

{code.valor = compilation-unit.node}

compilation-unit: #Done
	| optional-using-directive (1) optional-namespace-member-declaration (2)
	| optional-namespace-member-declaration (3)

-1 {using-node[] = optional-using-directive[]}
-2 {namespace-node[] = optional-namespace-member-declaration[]}
-3 {namespace-node[]= optional-namespace-member-declaration[]}

optional-using-directive: #DONE
	| using-directive (1)
	| EPSILON (2)

-1 {optional-using-directive.valor = using-directive(optional-using-directive.param?? new using-node[])}
-2 {optional-using-directive.valor = optional-using-directive.param}

using-directive: #DONE
	| "using" identifier identifier-attribute ';' (1) optional-using-directive (2)

-1 {using-directive.param.add(new using-node())}
-2 {using-directive.valor = optional-using-directive(using-directive.param).valor}

optional-namespace-member-declaration: #DONE
	| namespace-member-declaration (1) 
	| EPSILON (2)

-1 {optional-namespace-member-declaration.valor = namespace-member-declaration(optional-namespace-member-declaration.param?? new namespace-node() )}
-2 {optional-namespace-member-declaration.valor = optional-namespace-member-declaration.param}

namespace-member-declaration:#DONE
	| namespace-declaration (1) optional-namespace-member-declaration (2)
	| (3) type-declaration-list optional-namespace-member-declaration (4)

-1 { namespace-member-declaration.param.add(namespace-declaration()) }
-2 { namespace-member-declaration.valor = optional-namespace-member-declaration(namespace-member-declaration.param)}
-3 {namespace-member-declaration.param.add(type-declaration())}
-4 (namespace-member-declaration.valor = optional-namespace-member-declaration(namespace-member-declaration.param))

type-declaration-list:#DONE
	| (1) type-declaration (2) type-declaration-list
	| EPSILON (3)

-1 {type-declaration(type-declaration-list.param?? new namespace-node())}
-2 {type-declaration-list.valor =  type-declaration-list(type-declaration-list.param)}
-3 {type-declaration-list.valor = type-declaration-list.param}

type-declaration:#DONE
	| encapsulation-modifier group-declaration (1)

-1 {type-declaration.valor = type-declaration.param.type-declaration[].add(group-declaration(encapsulation-modifier.valor))}

namespace-declaration:#DONE
	| "namespace" identifier identifier-attribute namespace-body (1)
 -1 {
 	var namesNode = new namespace-node(identifier.lexema);
 	namespace-body(ref namesNode)
 	return namesNode;
 }

namespace-body:#DONE
	| '{' optional-using-directive optional-namespace-member-declaration '}'
	
identifier-attribute:#DONE
	| '.' identifier identifier-attribute
	| EPSILON

group-declaration: #DONE
	| class-declaration (1) #DONE
    | interface-declaration (2) #DONE
    | enum-declaration (3) #DONE
-1 {group-declaration.valor = class-declaration(group-declaration.param)} 
-2 {group-declaration.valor = interface-declaration(group-declaration.param)}
-3 {group-declaration.valor = enum-declaration(group-declaration.param)}

class-declaration: #DONE
	| (1) class-modifier "class" (2) identifier (3) inheritance-base (4) class-body optional-body-end

-1 { var isAbstract = class-modifier()}

-2 { var id = new identifierNode(token.lexema)}

-3 { var inheritance = inheritance-base() }

-4 {	 var classNode = new ClassNode(param.encapsulation,isAbstract, id, inheritance); 
		class-body(ref classNode) 
	}

#SEMANTIC: validar que no pueden haber private, ni protected enums afuera de un namespace.
encapsulation-modifier:#DONE
	| "public"
	| "protected"
	| "private"
	| EPSILON

class-modifier:
	| "abstract"
	| EPSILON

inheritance-base: #DONE
	| ':' identifiers-list (1)
	| EPSILON (2)

-1 { return identifiers-list()}
-2 { return null}


class-body: #DONE
	| '{' (1) optional-class-member-declaration-list '}'
-1 {
		optional-class-member-declaration-list(ref param.classNode)
	}

optional-class-member-declaration-list: #DONE
	| (1) class-member-declaration (2) optional-class-member-declaration-list
	| EPSILON

-1  {
		class-member-declaration(ref param.ClassNode)
		optional-class-member-declaration-list(ref param.ClassNode)
	}

class-member-declaration: #DONE
	| (1) encapsulation-modifier (2) class-member-declaration-options

-1  {
		var encapsulation = encapsulation-modifier();
	}

-2  {
		class-member-declaration-options(encapsulation, ref param.classNode);
	}


; SEMANTIC: void solo puede ir en un method. validar constructor-declaration con look_ahead
; SEMANTIC: los fields solo pueden llevar static. Y no ninguno demas de optional-modifier
class-member-declaration-options:
    | (1) optional-modifier (2) type-or-void (3) identifier (4) field-or-method
	| (5) constructor-declaration

-1	{ var modifier = optional-modifier() }
-2	{ var type = type-or-void() }
-3	{ var id = new identifierNode(currentToken) }
-4	{ field-or-method(param.encapsulation, modifier, type, id, ref classNode) }
-5	{ constructor-declaration(param.encapsulation, modifier, type(as id), ref classNode) }

field-or-method:
    | (1) field-declaration
	| (2) method-declaration

-1	{
		var assignment = field-declaration();
		var field = new field(param.encapsulation, param.modifier, param.type, param.id, assignment);
		ClassNode.fields.add(field);
	}
-2	{
		method-declaration(param.all);
	}

//SEMANTIC: Constructor no puede terminar con ;
constructor-declaration:
	| constructor-declarator maybe-empty-block

constructor-declarator:
	| identifier '(' fixed-parameters ')' constructor-initializer

constructor-initializer:
	| ':' "base" '(' argument-list ')'
	| EPSILON

optional-body-end:
	| ';'
	| EPSILON

identifiers-list: #DONE
	| qualified-identifier (1) identifiers-list-p

-1 { 
	var qualified-identifier = qualified-identifier();
	var list = identifiers-list-p()
	list.insert(0, qualified-identifier)
	return list;
	}

identifiers-list-p:
	| ',' qualified-identifier (1) identifiers-list-p (2)
	| EPSILON (3)

-1 { 
		var qualified-identifier = qualified-identifier()
		var list = identifiers-list-p();
	}
-2  {
		list.insert(0,qualified-identifier)
		return list;
	}

-3  {
		return new List<qualified-identifier>()
	}


===================================================

optional-statement-list:
	| statement-list (1)
	| EPSILON (2)

-1: { return statement-list }
-2: { return new List<StatementNode>() }

statement-list: 
	| (1) statement (2) optional-statement-list (3)

-1: { var stmnt = statement }
-2: { var stamnts = optional-statement-list }
-3: { 	stamsts.Insert(0, stmnt); 
		return stamnts; 
	}

statement:
	| (1) local-variable-declaration ';'
	| (2) embedded-statement
-1: { return local-variable-declaration } //Consumir ';' antes del return
-2: { return embedded-statement }

embedded-statement:
	| (1) maybe-empty-block
	| (2) statement-expression ';'
	| (3) selection-statement
	| (4) iteration-statement
	| (5) jump-statement ';'

-1: { return maybe-empty-block }
-2: { return statement-expression }
-3: { return selection-statement }
-4: { return iteration-statement }
-5: { return jump-statement }

iteration-statement:
	| (1) while-statement
	| (2) do-statement
	| (3) for-statement
	| (4) foreach-statement

-1: { return while-statement }
-2: { return do-statement }
-3: { return for-statement }
-4: { return foreach-statement }

maybe-empty-block:
	| '{' (1) optional-statement-list '}'
	| (2) ';'

-1: { return new BlockStatementNode( optional-statement-list ) }
-2: { return null }

while-statement:
	| "while" '(' expression (1) ')' embedded-statement (2)

-1: { var conditional = expression }
-2: { 	var body = embedded-statement; 
		return new WhileStamtentNode(conditional, body); 
	}

do-statement: 
	| "do" embedded-statement (1) "while" '(' expression (2) ')' ';'

-1: { 	var body = embedded-statement; 
	}
-2: { 	var conditional = expression 
		return new DoStatementNode(conditional, body); 
	}

for-statement:
	| "for" '(' (1) optional-for-initializer ';' (2) optional-expression ';' (3) optional-statement-expression-list ')' (4) embedded-statement (5)

-1: { var initializer = optional-for-initializer }
-2: { var expression = optional-expression }
-3: { var increment = optional-statement-expression-list }
-4: { var body = embedded-statement }
-5: { return new ForStatementNode(initializer, expression, increment, body) }

foreach-statement:
	| "foreach" '(' (1) type-or-var (2) identifier "in" (3) expression ')' (4) embedded-statement (5)

-1: { var type = type-or-var }
-2: { var type.identifier = identifier }
-3: { var collection = expression }
-4: { var body = embedded-statement }
-5: { return new ForeachStatementNode(type, collection, body) }

jump-statement:
	| "break" (1)
	| "continue" (2)
	| "return" optional-expression (3)

-1: { return new JumpStatement(break, null) }
-2: { return new JumpStatement(continue, null) }
-3: { return new JumpStatement(return, optional-expression) }

optional-statement-expression-list:
	| statement-expression-list (1)
	| EPSILON (2)

-1: { return statement-expression-list }
-2: { return null }

statement-expression-list:
	| (1) statement-expression (2) statement-expression-list-p

-1: { 	var stmt = statement-expression }
-2: { 	var stmts = statement-expression-list-p;
		stmts.Insert(0, stmt);
		return stmts;
	}

statement-expression-list-p:
	| ',' (1) statement-expression-list
	| EPSILON (2)

-1: { return statement-expression-list }
-2: { return new List<StatementNode>() }

optional-expression: 
	| expression (1)
	| EPSILON (2)

-1: { return expression }
-2: { return null }

optional-for-initializer:
	| local-variable-declaration (1)
	| statement-expression-list (2)
	| EPSILON (3)

-1: { return new List<StatementNode>(local-variable-declaration) }
-2: { return statement-expression-list }
-3: { return null }

selection-statement:
	| if-statement (1)
	| switch-statement (2)

-1: { return if-statement }
-2: { return switch-statement }

switch-statement:
	| "switch" '(' (1) expression ')' '{' (2) optional-switch-section-list '}' (3)

-1: { var constantExpression = expression }
-2: { var cases = optional-switch-section-list }
-3: { return new SwitchStatementNode(constantExpression, cases); }

optional-switch-section-list:
	| (1) switch-label-list (2) statement-list (3) optional-switch-section-list (4)
	| EPSILON (5)

-1: { var toCompare = switch-label-list }
-2: { var body = statement-list }
-3: { var otherCases = optional-switch-section-list }
-4: { 
		otherCases.insert(0, new CaseExpressionNode(toCompare, body) );
		return otherCases;
	}
-5: { return new List<CaseExpressionNode>() }

switch-label-list:
	| switch-label (1) ':' switch-label-list-p (2)

-1: { 	var label = switch-label }
-2: { 	var otherLabels = switch-label-list-p
		otherLabels.Insert(0, label);
		return otherLabels;
	}

switch-label-list-p:
	| switch-label-list (1)
	| EPSILON (2)

-1: { return switch-label-list }
-2: { return new List<CaseNode>() }
	
switch-label:
	| "case" expression (1)
	| "default" (2)

-1: { return new CaseNode(case, expression) }
-2: { return new CaseNode(default, null) }

if-statement:
	| "if" '(' (1) expression ')' (2) embedded-statement (3) optional-else-part (4)

-1: { var conditional = expression }
-2: { var body = embedded-statement }
-3: { var else = optional-else-part }
-4: { return new IfStatementNode(conditional, body, else); }

optional-else-part:
	| else-part (1)
	| EPSILON (2)

-1: { return else-part }
-2: { return null }

else-part:
	| "else" embedded-statement	(1)

-1: { return new ElseNode( embedded-statement ) }

statement-expression:
	| unary-expression statement-expression-factorized

//nueva produccion
statement-expression-factorized:
	| assignment-operator expression statement-expression-p
	| statement-expression-p
//Borrar optional-unary-expression (innesesario)
optional-unary-expression:
    | expression-unary-operator unary-expression
    | '(' type ')'
    | EPSILON

local-variable-declaration:
	| type-or-var variable-declarator-list	

fixed-parameter: #DONE
	| (1) type (2) identifier (3)

-1  {var type = type()}

-2  {var id= new identifierNode(identifier.lexema)}

-3  {return new parameter(type, id) }


fixed-parameters: #DONE
	| (1) fixed-parameter (2) fixed-parameters-p (3)
	| EPSILON (4)

-1  {
		var parameter = fixed-parameter();
	}

-2  {
		var list = fixed-parameters-p();
	}

-3  {
		list.insert(0, parameter);
		return list;
	}
-4  {
		return new List<parameter>();
	}

fixed-parameters-p: #DONE
	| ',' (1) fixed-parameter (2) fixed-parameters-p (3)
	| EPSILON (4)
-1  {
		var parameter = fixed-parameter();
	}

-2  {
		var list = fixed-parameters-p();
	}

-3  {
		list.insert(0, parameter);
		return list;
	}
-4  {
		return new List<parameter>();
	}

type: #DONE
	| dictionary (1) optional-rank-specifier-list (2)
	| built-in-type (3) optional-rank-specifier-list (4)
	| qualified-identifier (5) optional-rank-specifier-list (6)

-1  {
		var dictionary =  dictionary();
	}

-2  {
		return new Type(dictionary, optional-rank-specifier-list())

-3  {
		var primitiveType = built-in-type()
	}
-4  {
		return new Type(primitiveType, optional-rank-specifier-list())
	}
-5  {
		var qualified-identifier = qualified-identifier();
	}

-6  {
		return new Type(qualified-identifier, optional-rank-specifier-list())
	}


//nueva
dictionary: #DONE
	| "Dictionary" '<' (1) type ',' (2) type '>' (3)

-1  {
		var type1 = type();
	}
-2  {
		var type2 = type();
	}
-3  {
		return new Dictionary(type1, type2);
	}

//nueva
built-in-type: #DONE
	| "int" { return new IntType() }
	| "char" { return new CharType() } 
	| "string" {}
	| "bool" {}
	| "float" {}
//nueva
qualified-identifier: #DONE
	| identifier (1) identifier-attribute (2)

-1  { 
		var identifier = identifier();
		var lista = identifier-attribute();
	}

-2  {
		lista.insert(0, identifier);
		return lista;
	}

type-or-var:
	| type
	| "var"

type-or-void: #DONE
	| type (1)
	| "void" (2)

-1 { return type() }
-2 { return new Type(new VoidType(),null)}

argument-list:
	| expression argument-list-p
	| EPSILON

argument-list-p:
	| ',' expression argument-list-p
	| EPSILON

===============================================================

expression:
    | conditional-expression

conditional-expression:
	| null-coalescing-expression conditional-expression-p

conditional-expression-p:
	| '?' expression ':' expression 
	| EPSILON

null-coalescing-expression:
	| conditional-or-expression null-coalescing-expression-p

null-coalescing-expression-p:
	| "??" null-coalescing-expression
	| EPSILON

conditional-or-expression:
	| conditional-and-expression conditional-or-expression-p

conditional-or-expression-p:
	| "||" conditional-and-expression conditional-or-expression-p 
	| EPSILON

conditional-and-expression:
	| inclusive-or-expression conditional-and-expression-p

conditional-and-expression-p:
	| "&&" inclusive-or-expression conditional-and-expression-p
	| EPSILON 

inclusive-or-expression:
	| exclusive-or-expression inclusive-or-expression-p

inclusive-or-expression-p:
	| "|" exclusive-or-expression inclusive-or-expression-p
	| EPSILON

exclusive-or-expression:
	| and-expression exclusive-or-expression-p

exclusive-or-expression-p:
	| "^" and-expression exclusive-or-expression-p
	| EPSILON 

and-expression:
	| equality-expression and-expression-p

and-expression-p:
	| "&" equality-expression and-expression-p
	| EPSILON

equality-expression:
	| relational-expression equality-expression-p

equality-expression-p:
	| expression-equality-operator relational-expression equality-expression-p
	| EPSILON

relational-expression:
	| shift-expression relational-expression-p

relational-expression-p:
	| expression-relational-operator shift-expression relational-expression-p
	| is-as-operators type relational-expression-p
	| EPSILON 

shift-expression:
	| additive-expression shift-expression-p

shift-expression-p:
	| expression-shift-operator additive-expression shift-expression-p
	| EPSILON

additive-expression:
	| multiplicative-expression additive-expression-p

additive-expression-p:
	| additive-operators multiplicative-expression additive-expression-p
	| EPSILON

multiplicative-expression:
	| unary-expression multiplicative-expression-factorized

multiplicative-expression-factorized:
	| assignment-operator expression multiplicative-expression-p
	| multiplicative-expression-p

multiplicative-expression-p:
	| multiplicative-operators unary-expression multiplicative-expression-p
	| EPSILON	

is-as-operators:
	| "is"
	| "as"

multiplicative-operators:
	| '*'
	| '/'
	| '%'

additive-operators:
	| '+'
	| '-'
expression-shift-operator: 
	| "<<"
	| ">>"

expression-equality-operator:
	| "=="
	| "!="

expression-relational-operator:
	| '<'
	| '>'
	| "<="
	| ">="

assignment-operator:
	| '='
	| "+="
	| "-="
	| "*="
	| "/="
	| "%="
	| "&="
	| "|="
	| "^="
	| "<<="
	| ">>="

unary-expression: //look_ahead dos veces PROGRAMATICALLY
	| expression-unary-operator unary-expression
	| '(' type ')' primary-expression
	| primary-expression

expression-unary-operator:
	| '+'
	| '-'
	| increment-decrement
	| "!"
	| "~"
	| "*"

# REVISAR 'BASE'
//SEMANTIC: validar que un literal no puede tener una llamada a
//  funcion por la llamda a primary-expression-p
primary-expression:
    | "new" instance-expression primary-expression-p
	| literal primary-expression-p
	| identifier primary-expression-p
	| "base" primary-expression-p
	| '(' expression ')' primary-expression-p
	| "this" primary-expression-p

instance-expression:
	| type instance-expression-factorized

instance-expression-factorized:
	| '[' instance-expression-factorized-p 
	| '(' argument-list ')'

instance-expression-factorized-p:
	| expression-list ']' optional-rank-specifier-list optional-array-initializer
	| rank-specifier-list array-initializer

primary-expression-p:
    | '.' identifier primary-expression-p
    | optional-funct-or-array-call primary-expression-p
    | increment-decrement primary-expression-p 
    | EPSILON

optional-funct-or-array-call:
	| '(' argument-list ')'
	| optional-array-access-list 

optional-array-access-list:
	| '[' expression-list ']' optional-array-access-list
	| EPSILON

literal:
	| int-literal
	| char-literal
	| float-literal
	| string-literal
	| "true"
	| "false"

expression-list:
	| expression expression-list-p 

expression-list-p:
	| ',' expression-list
	| EPSILON

rank-specifier-list: #DONE
	| (1) rank-specifier  (2) optional-rank-specifier-list

-1  {
		rank-specifier(ref param.ArrayType);
	}	

-2  {
		optional-rank-specifier-list(ref param.ArrayType)
	}	

optional-rank-specifier-list: #DONE
	| '[' (1) rank-specifier-list
	| EPSILON

-1  {
		rank-specifier-list(ref Param.ArrayType);
	}

rank-specifier: #DONE
	| (1) optional-comma-list ']' (2)

-1  {
		optional-comma-list(ref param.ArrayType)
	}

-2 	{
		param.ArrayType.arrayOfArrays +=1;
	}

optional-comma-list: #DONE
	| (1) comma-list
	| EPSILON

-1  {
		comma-list(ref param.ArrayType)
	}

comma-list: #DONE
	| ',' (1) optional-comma-list

-1  {
		param.ArrayType.dimensions++;
		optional-comma-list(ref param.ArrayType);
	}

;SEMANTIC: Validar que si la clase es abstract, el metodo no debe llevar cuerpo.
method-declaration:
	| '(' fixed-parameters ')' maybe-empty-block

interface-method-header: #DONE
	| type-or-void identifier (1) '(' fixed-parameters ')' (2)

-1  {
		var type = type-or-void()
		var method = new methodPrototype(type, identifiers)
		method.parameters = fixed-parameters();
	}

-2  {
		return method;
	}

field-declaration: 
	| (1) variable-assigner (2) variable-declarator-list-p ';'
-1	{
		var assignmentExpression = variable-assigner();
	}

-2 	{
		var list = variable-declarator-list-p();
		var new AssignmentNode(assignmentExpression, list);
	}
variable-declarator-list:
	| identifier variable-assigner variable-declarator-list-p

variable-assigner:
	| '=' (1) variable-initializer
	| EPSILON (2)

-1	{
		var assignment_expression = variable-initializer();
		return assignment_expression;
	}

-2	{ return null;}

variable-declarator-list-p:
	| ',' variable-declarator-list
	| EPSILON

variable-initializer:
	| (1) expression
	| (2) array-initializer

#CONSIDERACION: los nodos expression, y arrayInitializer que se devuelven, ambos son hijos de la abstract class variableInitializer
-1  {
		return expression();
	}

-2  {	
		return array-initializer();
	}

#SEMANTICO: Validar que static solo puede estar en field. Virtual, override y abstract, unicamente en method.
optional-modifier:
    | "static"
    | "virtual"
    | "override"
    | "abstract"
    | EPSILON

interface-declaration:  #DONE
	| "interface" identifier (1) inheritance-base (2) interface-body (3) optional-body-end

-1  {
		var interface = new Interface(identifier.lexema)
		interface.inheritance = inheritance-base();
	}

-2  {
		interface.methotds[] =  interface-body();
	}

interface-body: #DONE
	| '{' (1) interface-method-declaration-list '}'

-1 {return interface-method-declaration-list() }

interface-method-declaration-list: #DONE
	| interface-method-header ';' (1) interface-method-declaration-list (2)
	| EPSILON (3)

-1  {
		var interface-method-header = interface-method-header();
		var list = interface-method-declaration-list()
	}

-2  {
		list.insert(0,interface-method-header)
		return list;
	}

-3 	{
		return new List<interface-method-declarationNode>
	}

enum-declaration: #DONE
	| "enum" identifier enum-body (1) optional-body-end (2)

-1 {new enum-definition-node(enum-declaration.param, identifier).enum-node[] = enum-body()}
-2 {enum-declaration.valor = enum-definition-node}

enum-body:#DONE
	| '{' optional-assignable-identifiers-list '}' (1)

-1  {enum-body.valor = optional-assignable-identifiers-list(new enum-node[]).valor}

optional-assignable-identifiers-list:#DONE
	| identifier (1) assignment-options (2)
	| EPSILON (3)

-1 {assignment-options(new identifier-node(identifier.lexema), ref optional-assignable-identifiers-list.param)}
-3 {return optional-assignable-identifiers-list.param}

assignment-options:#DONE
	| optional-assignable-identifiers-list-p (1)
	| '=' expression optional-assignable-identifiers-list-p (2)

-1 { optional-assignable-identifiers-list-p(assignment-options.param1, ref assignment-options.param2, null) }
-2 { optional-assignable-identifiers-list-p(assignment-options.param1, ref assignment-options.param2, expresion.valor}

optional-assignable-identifiers-list-p: #DONE
	| ',' (1) optional-assignable-identifiers-list
	| EPSILON (2)

	//param1 = identifier-node
	//param2 = enum-node[]
	//param3 = enum.valor

-1  {	optional-assignable-identifiers-list-p.param2.add(new enum-Node(param1,param3))
		optional-assignable-identifiers-list(param2)
	}

-2  {	
		optional-assignable-identifiers-list-p.param2.add(new enum-Node(param1,param3))
	}
optional-array-initializer:
	| array-initializer
	| EPSILON

array-initializer: 
	| '{' (1) optional-variable-initializer-list '}'

-1  {
		var array_init = new arrayInitializer()
		array_init.list =  optional-variable-initializer-list(); 
		return array_init;
	}

optional-variable-initializer-list:
	| variable-initializer-list
	| EPSILON

variable-initializer-list:
	| (1) variable-initializer (2) variable-initializer-list-p

-1	{
		var var_init = variable-initializer();
	}

-2  {
		var lista = variable-initializer-list-p();
		lista.insert(0, var_init);
	}

variable-initializer-list-p:
	| ',' (1) variable-initializer-list
	| EPSILON (2)

-1  {
		return variable-initializer-list();
	}

-2  {
		return new List<variableInitializer>();
	}

increment-decrement:
	| "++"
	| "--"

statement-expression-p:
	| '(' argument-list ')'
	| increment-decrement
    | EPSILON